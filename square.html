<!DOCTYPE html>
<html>
<head>
    <title>Neon Jump Pro</title>
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { border: 3px solid #00ffcc; background: #000; box-shadow: 0 0 20px #00ffcc; cursor: pointer; }
        .ui { margin-bottom: 10px; text-align: center; }
        #resetBtn { margin-top: 15px; padding: 10px 20px; background: #ff0055; color: white; border: none; border-radius: 5px; cursor: pointer; display: none; font-weight: bold; }
        #resetBtn:hover { background: #ff3377; }
    </style>
</head>
<body>
    <div class="ui">
        <div>Score: <span id="currentScore">0</span> | High Score: <span id="highScore">0</span></div>
        <div style="font-size: 0.8em; color: #888;">Press SPACE or Click to Jump</div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <button id="resetBtn" onclick="resetGame()">Try Again</button>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("currentScore");
        const highEl = document.getElementById("highScore");
        const resetBtn = document.getElementById("resetBtn");

        canvas.width = 800;
        canvas.height = 250;

        // Game State
        let score = 0;
        let highScore = localStorage.getItem("neonJumpHigh") || 0;
        highEl.innerText = highScore;
        let gameActive = true;
        let frame = 0;
        let obstacles = [];

        const player = {
            x: 80,
            y: 200,
            size: 30,
            dy: 0,
            jumpForce: 13,
            gravity: 0.8,
            grounded: false
        };

        function spawnObstacle() {
            // Spawns an obstacle every 100 frames
            if (frame % 100 === 0) {
                obstacles.push({
                    x: canvas.width,
                    width: 25,
                    height: 30 + Math.random() * 40,
                    passed: false
                });
            }
        }

        function update() {
            if (!gameActive) return;

            // Player Physics
            player.dy += player.gravity;
            player.y += player.dy;

            // Floor collision
            if (player.y + player.size > canvas.height) {
                player.y = canvas.height - player.size;
                player.dy = 0;
                player.grounded = true;
            }

            // Obstacle Logic
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= 6; // Speed

                // Scoring: If player passes the obstacle
                if (!obs.passed && obs.x < player.x) {
                    score++;
                    obs.passed = true;
                    scoreEl.innerText = score;
                }

                // Collision Detection
                if (
                    player.x < obs.x + obs.width &&
                    player.x + player.size > obs.x &&
                    player.y + player.size > canvas.height - obs.height
                ) {
                    gameOver();
                }

                // Remove off-screen obstacles
                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                }
            }

            frame++;
            spawnObstacle();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Ground Line
            ctx.strokeStyle = "#444";
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.stroke();

            // Draw Player
            ctx.fillStyle = "#00ffcc";
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00ffcc";
            ctx.fillRect(player.x, player.y, player.size, player.size);

            // Draw Obstacles
            ctx.fillStyle = "#ff0055";
            ctx.shadowColor = "#ff0055";
            obstacles.forEach(obs => {
                ctx.fillRect(obs.x, canvas.height - obs.height, obs.width, obs.height);
            });

            // Reset shadow for performance
            ctx.shadowBlur = 0;

            update();
            if (gameActive) {
                requestAnimationFrame(draw);
            }
        }

        function gameOver() {
            gameActive = false;
            resetBtn.style.display = "block";
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("neonJumpHigh", highScore);
                highEl.innerText = highScore;
            }
        }

        function resetGame() {
            score = 0;
            scoreEl.innerText = 0;
            obstacles = [];
            frame = 0;
            player.y = 200;
            player.dy = 0;
            gameActive = true;
            resetBtn.style.display = "none";
            draw();
        }

        function handleJump() {
            if (player.grounded && gameActive) {
                player.dy = -player.jumpForce;
                player.grounded = false;
            }
        }

        // Controls
        window.addEventListener("keydown", (e) => { if (e.code === "Space") handleJump(); });
        canvas.addEventListener("mousedown", handleJump);
        canvas.addEventListener("touchstart", (e) => { e.preventDefault(); handleJump(); });

        // Start
        draw();
    </script>
</body>
</html>
