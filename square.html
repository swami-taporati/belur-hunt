<!DOCTYPE html>
<html>
<head>
    <title>Neon Jump: Level Up</title>
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        canvas { border: 3px solid #00ffcc; background: #000; box-shadow: 0 0 30px rgba(0, 255, 204, 0.3); cursor: pointer; }
        .ui { margin-bottom: 15px; text-align: center; width: 800px; display: flex; justify-content: space-between; align-items: flex-end; }
        .stat { background: #333; padding: 5px 15px; border-radius: 4px; border-bottom: 3px solid #00ffcc; }
        #resetBtn { margin-top: 15px; padding: 12px 25px; background: #00ffcc; color: #000; border: none; border-radius: 5px; cursor: pointer; display: none; font-weight: bold; font-size: 1.2em; text-transform: uppercase; }
        #resetBtn:hover { background: #fff; }
    </style>
</head>
<body>
    <div class="ui">
        <div class="stat">SCORE: <span id="currentScore">0</span></div>
        <div id="levelDisplay" style="color: #ff0055; font-weight: bold; font-size: 1.5em;">LEVEL 1</div>
        <div class="stat">HIGH: <span id="highScore">0</span></div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    <button id="resetBtn" onclick="resetGame()">Restart Mission</button>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("currentScore");
        const highEl = document.getElementById("highScore");
        const levelEl = document.getElementById("levelDisplay");
        const resetBtn = document.getElementById("resetBtn");

        canvas.width = 800;
        canvas.height = 250;

        let score = 0;
        let highScore = localStorage.getItem("neonLevelHigh") || 0;
        highEl.innerText = highScore;
        
        let gameActive = true;
        let frame = 0;
        let obstacles = [];
        let gameSpeed = 6;
        let currentLevel = 1;
        
        // Notification system
        let announcementText = "";
        let announcementTimer = 0;

        const player = { x: 80, y: 200, size: 30, dy: 0, jumpForce: 13, gravity: 0.8, grounded: false };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(freq, duration, type = "square") {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(type === "square") osc.frequency.exponentialRampToValueAtTime(freq * 2, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function checkLevelUp() {
            // Level up every 500 distance units (roughly every 5-10 obstacles)
            let newLevel = Math.floor(frame / 600) + 1;
            if (newLevel > currentLevel) {
                currentLevel = newLevel;
                levelEl.innerText = `LEVEL ${currentLevel}`;
                announcementText = "LEVEL UP! SPEED INCREASED";
                announcementTimer = 100; // Show for 100 frames
                score += 50; // Level up bonus
                playSound(600, 0.3, "sine"); // Level up chime
            }
        }

        function spawnObstacle() {
            let spawnRate = Math.max(35, 90 - (currentLevel * 5));
            if (frame % spawnRate === 0) {
                let hue = Math.max(0, 340 - (currentLevel * 20));
                obstacles.push({
                    x: canvas.width,
                    width: 25,
                    height: 30 + Math.random() * 50,
                    color: `hsl(${hue}, 100%, 60%)`,
                    passed: false,
                    points: 5 + (currentLevel * 2) 
                });
            }
        }

        function update() {
            if (!gameActive) return;

            gameSpeed = 5 + (currentLevel * 1.2);
            player.dy += player.gravity;
            player.y += player.dy;

            if (player.y + player.size > canvas.height) {
                player.y = canvas.height - player.size;
                player.dy = 0;
                player.grounded = true;
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                if (!obs.passed && obs.x < player.x) {
                    score += obs.points;
                    obs.passed = true;
                    scoreEl.innerText = score;
                }

                if (player.x < obs.x + obs.width && player.x + player.size > obs.x &&
                    player.y + player.size > canvas.height - obs.height) {
                    gameOver();
                }
                if (obs.x + obs.width < 0) obstacles.splice(i, 1);
            }

            frame++;
            checkLevelUp();
            spawnObstacle();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Player with trail effect
            ctx.fillStyle = "#fff";
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00ffcc";
            ctx.fillRect(player.x, player.y, player.size, player.size);

            // Draw Obstacles
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.color;
                ctx.shadowColor = obs.color;
                ctx.fillRect(obs.x, canvas.height - obs.height, obs.width, obs.height);
            });

            // Draw Announcement
            if (announcementTimer > 0) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = `rgba(255, 255, 255, ${announcementTimer / 100})`;
                ctx.font = "bold 30px Courier New";
                ctx.textAlign = "center";
                ctx.fillText(announcementText, canvas.width/2, canvas.height/2);
                announcementTimer--;
            }

            ctx.shadowBlur = 0;
            update();
            if (gameActive) requestAnimationFrame(draw);
        }

        function gameOver() {
            gameActive = false;
            playSound(100, 0.5, "sawtooth"); // Game over sound
            resetBtn.style.display = "block";
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("neonLevelHigh", highScore);
                highEl.innerText = highScore;
            }
        }

        function resetGame() {
            score = 0; scoreEl.innerText = 0;
            obstacles = []; frame = 0; currentLevel = 1;
            levelEl.innerText = "LEVEL 1";
            player.y = 200; player.dy = 0;
            gameActive = true; resetBtn.style.display = "none";
            draw();
        }

        function handleJump() {
            if (player.grounded && gameActive) {
                player.dy = -player.jumpForce;
                player.grounded = false;
                playSound(200, 0.1, "square");
            }
        }

        window.addEventListener("keydown", (e) => { if (e.code === "Space") handleJump(); });
        canvas.addEventListener("mousedown", handleJump);
        draw();
    </script>
</body>
</html>
